# Time series data
[Link to working code](../source/src/main/java/com/aerospike/examples/timeseries/TimeSeriesDemo.java)

## Use case
Cameras or other devices record events at random times as stimuli (eg motion) cause events to be generated. These devices are associated with an account, and it is expected than an account will have no more than about 50 devices. Each device will generate multiple events.

There will be a very large number of accounts, but the number of devices per account will be low (< 50) and the number of events per device will also be relatively low (< 1000 per day).

### Queries which need to be answered are:
- Insert an event
- Update an event
- Query events by a date range with the following features:
    - Events are returned in order, either ascending or descending aas specified
    - Pagination forwards or backwards should be allowed
    - if no dates are specified, return the most recent eventws
    - The time range start, the time range end and the event used for pagination are all optional; the system should behave appropriately if any or all of these parameters are not passed.
    - One or more device ids can be specified. If any devices are specified, the events are filtered down to just the specified devices.

The difference between an insert and an update is that the insert should set the TTL of the records to the number of days specified in the use case (14). An update should not alter the TTL of the record.

## Data model
Since the number of devices per account, and the number of events per device are both low, we can come up with a simple data model. For each day, we can store all the events for all the devices in one Aerospike record. We compute an offset from a fixed point in time (eg 1/1/2024) with 1st Jan 2024 being day 0, 2nd Jan 2024 being day 1, etc. This give us a date offset: 

```
dateOffset = computeDaysBetween("1/1/2024", targetTimestamp)
```

We can use the `dateOffset` plus the `accountId` to give us a unique primary key per day per account:

```java
String recordKey = event.accountId() + getDateOffset(event.getTimestamp());
```

### Filtering by time
Each event has a timestamp, and we will use this for ordering and filtering. However a timestamp is not guaranteed to be unique, it's possible for two events to be generated by two different devices on the same account at the same time. Hence, to solve this, we need to add some extra digits to the end, so `timestamp + randomPart`. For example, `1753652536758000993192600` is comprised of a 13 digit timestamp (`1753652536758`) plus a 12 digit random part (`000993192600`)

In this example, we will assume this 25 digit number forms a account-unique `eventId`, and use this as the event of the record. If this is not the case, a synthetic one can be generated using a timestamp.

So inside our Aerospike record, we will store String keys in a Map inside a Bin called "map":
```
map: {
    "1753652625131001737686856": ...
    "1753652539753001677738280": ...
    "1753652536758000993192600": ...
}
```

So long as we create the map as a `KEY_ORDERED` map, Aerospike will ensure that the events are stored in ascending order as we add / update new events. We can retrieve events from the map using map operations like `getByKeyRange`, providing we pass the desired timestamps as eventIds. 

Great, this satisfies the filtering requirement by date range. The pagination can be satisfied by careful selection of the event range. For example, in the map above, if the last key shown was `1753652625131001737686856` and we're descending we can end the next range at this same key (as the Aerospike `getByKeyRange` method is __exclusive__ of the end key). If we're ascending, we would need to start the next page at `1753652625131001737686856 + 1` as the function call is __inclusive__ of the start key.

There are three parameters which will affect the range of values returned: 
- The start timestamp, if passed
- The end timestamp, if passed,
- The last returned eventId, if passed.

We can combine these three parameters into a start and end eventId using:

```java
if (eventId != null) {
    if (direction == SortDirection.ASCENDING) {
        // Run from AFTER event id up to endTimestamp, or now if not specified
        earliestEventId = generateNextEventId(eventId);
        latestEventId = eventIdFromTimestamp(getLatestTimestamp(endTimestamp), false);
    }
    else  {
        // Run from startTimestamp, or now - 14 days, to the eventId. Note that as the
        // end event is exclusive, we do not need to calculate a prior event id.
        latestEventId = eventId;
        earliestEventId = eventIdFromTimestamp(getOldestTimestamp(startTimestamp), true);
    }
}
else {
    // Full date range, don't care about ascending or descending
    latestEventId = eventIdFromTimestamp(getLatestTimestamp(endTimestamp), false);
    earliestEventId = eventIdFromTimestamp(getOldestTimestamp(startTimestamp), true);
}
```

We may need multiple records to cover the date range. For example, if the date range is three days, and we have one record per day, we will likely have to get 4 records -- a partial record at the end of the start record, two full recods in between, and the start of partial record at the end.

```java
long startRecord = getDayOffset(extractTimestampFromEventId(earliestEventId));
long endRecord = getDayOffset(extractTimestampFromEventId(latestEventId));
```

### Filtering by device
In order to be able to filter by device id, we can store the device for an event as the first part of the value associated with the timestamp. We also need to store the details of the event, so let's go ahead and put this into a list. A list is needed because Aerospike can easily compare two lists in a way which will help us with the use case, but it cannot do the same with maps. So the data model would look like:

```
map: {
    "1753652625131001737686856": ["device-1", {...}]
    "1753652539753001677738280": ["device-3", {...}]
    "1753652536758000993192600": ["device-7", {...}]
}
```

The value in the elipsis (`...`) above are the details for the events, we will come back to this later.

Now the Aerospike Map API provides a method `getByValueList` where we can provide a list of `Value`s, and Aerospike will return any values that match. However, we have to be a bit careful here. If we pass `Value.get("device-1")` this will **NOT** match any values, even the first one. The reason is that we have passed a String (`"device-1"`) but the map value is a List `["device-1", {...}]`. We're comparing different types, so this will always fail.

What we need to do is wrapper the comparison in a list: `Value.get(List.of("device-1"))`. This will ensure that we're comparing the right types, so Aerospike will descend into both lists and compare the first element. If we're comparing against `["device-1", {...}]` they will match, so Aerospike will go on and compare the next element. The list we've passed doesn't contain more than one element so this comparison fails. So we need to change the list we pass to be `Value.get(List.of("device-1", Value.WILDCARD))`. To turn a list of device ids into a list of Values to use, we can use something like:

```java
List<Value> valueList = Arrays.stream(deviceIds)
    .map(deviceId -> Value.get(List.of(deviceId, Value.WILDCARD)))
    .collect(Collectors.toList());
```

Now we have two different filters:
- Date range using `getByKeyRange`
- Device list using `getByValueList`

We need to use both, but the `MapOperation` class does not allow this. However, using a read expression with an `ExpOperation` does allow this! Consider the following method:

```java
private Operation createTimeRangeAndDeviceFilter(String oldestEventId, String newestEventId, List<Value> valueList) {
    Exp filterMapByKeyRange = MapExp.getByKeyRange(MapReturnType.KEY_VALUE, 
            Exp.val(oldestEventId), Exp.val(newestEventId), Exp.mapBin(DatabaseConfig.BIN_NAME));
    
    Exp filterKeyRangeByDevice = MapExp.getByValueList(MapReturnType.KEY_VALUE, 
            Exp.val(valueList), filterMapByKeyRange);
    
    return ExpOperation.read(DatabaseConfig.BIN_NAME, 
        Exp.build(filterKeyRangeByDevice), ExpReadFlags.DEFAULT);
}
```

In this code we define the time range first in `filterMapByKeyRange` for all event ids between `oldestEvent` (inclusive) and `newestEventId` (exclusive) on the records in the map in `map`. We ask for the results as `KEY_VALUE`s, so the result is a map which is the original map with the events outside the time range filtered out.

We take this new map and apply the `getByValueList` onto this by passing the `filterMapByKeyRange` as the Map. This gives us a combination of the filters. Note that the order is irrelevant to the result, but doing the key range first is more efficient as Aerospike already stores the records in this order.

### Retrieving the events
Once the filters are applied, we just need to retrieve the results. In some cases, we will need to load multiple records, for example if querying over several days of events. Collating the events from multiple records is easy, we just have to be careful of the order (ascending or descending).

```java
if (direction == SortDirection.ASCENDING) {
    for (long recordKey = startRecord; 
            results.size() < count && recordKey <= endRecord; 
            recordKey++) {
           
       Key key = new Key(DatabaseConfig.NAMESPACE, DatabaseConfig.EVENT_SET, accountId + ":" + recordKey);
       Record record = client.operate(null, key, operation);
       addEventsToResults(count, record, results, direction);
    }            
}
else {
    for (long recordKey = endRecord; 
            results.size() < count && recordKey >= startRecord; 
            recordKey--) {
           
       Key key = new Key(DatabaseConfig.NAMESPACE, DatabaseConfig.EVENT_SET, accountId + ":" + recordKey);
       Record record = client.operate(null, key, operation);
       addEventsToResults(count, record, results, direction);
    }            
}
```

### Storing the event details
The second value in the event list is a map comprising of the event details. This is simply a map, and can be formed in any way. The sample code provides methods to turn an `Event` into a `Map` and another to turn a `Map` into an `Event`:

```java
public static Map<String, Object> convertEventToMap(Event event) {
    if (event == null) {
        throw new IllegalArgumentException("Event cannot be null");
    }
    
    return Map.of(
        "id", event.getId(),
        "accountId", event.getAccountId(),
        "deviceId", event.getDeviceId(),
        "params", event.getParameters(),
        "resolution", event.getResolution(),
        "videoMeta", event.getVideoMeta(),
        "paramTags", event.getParameterTags(),
        "partnerId", event.getPartnerId(),
        "partStateId", event.getPartnerStateId(),
        "timestamp", dateToLong(event.getTimestamp())
    );
}

public static Event convertMapToEvent(Map<String, Object> eventMap) {
    if (eventMap == null) {
        return null;
    }
    
    Event event = new Event();
    event.setId((String) eventMap.get("id"));
    event.setAccountId((String) eventMap.get("accountId"));
    event.setDeviceId((String) eventMap.get("deviceId"));
    event.setParameters((Map) eventMap.get("params"));
    event.setResolution((List) eventMap.get("resolution"));
    event.setVideoMeta((Map) eventMap.get("videoMeta"));
    event.setParameterTags((List) eventMap.get("paramTags"));
    event.setPartnerId((String) eventMap.get("partnerId"));
    event.setPartnerStateId((String) eventMap.get("partStateId"));
    event.setTimestamp(longToDate((Long) eventMap.get("timestamp")));
    
    return event;
}
```

There's nothing overly remarkable about these methods. However, we could potentially so some optimization: the `accountId` is part of the record key, the `id` is the map key and `deviceId` is the first value in the list in the map. We could in theory leave these items out of the map, and re-assemble the records from these disperate pieces of information. For simplicitly sake however, in this case we will just store everything in the map. 

### Data model optimization
In the above code we use each bucket being the same length as a day. This makes it easy to visualize and explain, but it's not terribly flexible. What if we want to store more events per day, or more devices and this model would result in very large records in Aerospike or RECORD_TOO_BIG exceptions?

One simple optimization is to make the number of hours a bucket covered to be adjustible. This is an easy change. We define a new constant:
```java
public static final int BUCKET_WIDTH_HOURS = 24;
```

Then all we need to do is replace `getDayOffset` with `getBucketOffset` and change it to caluclate the offset correctly:

```java
public static long getBucketOffset(long timestamp) {
    return (timestamp - TimeConfig.DATE_OFFSET_MILLIS) / (TimeConfig.MILLIS_PER_HOUR * TimeConfig.BUCKET_WIDTH_HOURS);
}
```
Now we have flexible bucket sizes just by changing the constant. 

## Running
The sample code generates a whole bunch of events against a configurable number of accounts, then runs some queries on them. To make sure it gives valid results, it generates at least 50 devices on account `acct-1`, with each device having up to 800 events over the 14-day window. When inspected with AQL, this data looks like:
```
"1752568353192001137812153": [
    "device-acct-7-8",
    {
    "accountId": "acct-7",
    "deviceId": "device-acct-7-8",
    "id": "1752568353192001137812153",
    "paramTags": [
        "accusantium dolores dolor suscipit blanditiis"
    ],
    "params": {
        "imageMeta": {
        "assetId": "",
        "frameIndex": 0,
        "storageLocation": "hv"
        },
        "imageUrl": "",
        "objectsDetected": [
        {
            "frameIndex": 0,
            "type": "person"
        },
        {
            "frameIndex": 0,
            "type": "motion"
        }
        ]
    },
    "partStateId": "sit repellendus est",
    "partnerId": "ediDPcoBweqbdPZyjGpa",
    "resolution": [
        85,
        97
    ],
    "timestamp": 1752568353192,
    "videoMeta": {
        "duration": 13,
        "videoUrl": "https://somewhere.com/4659278373492"
    }
    }
],
"1752568382558000130814851": [
    "device-acct-7-1",
    {
    "accountId": "acct-7",
    "deviceId": "device-acct-7-1",
    "id": "1752568382558000130814851",
    "paramTags": [
        "ullam laudantium",
        "provident",
        "corporis fuga alias eius",
        "laboriosam reprehenderit et et"
    ],
    "params": {
        "imageMeta": {
        "assetId": "",
        "frameIndex": 0,
        "storageLocation": "hv"
        },
        "imageUrl": "",
        "objectsDetected": [
        {
            "frameIndex": 0,
            "type": "person"
        },
        {
            "frameIndex": 0,
            "type": "motion"
        }
        ]
    },
    "partStateId": "odio odio iusto",
    "partnerId": "QYNIxacAxZFxbbJNYWJD",
    "resolution": [
        6,
        58
    ],
    "timestamp": 1752568382558,
    "videoMeta": {
        "duration": 13,
        "videoUrl": "https://somewhere.com/4659278373492"
    }
    }
],
```

The code will then run some queries:
```java
System.out.printf("Account acct-1 has %,d events%n%n", 
    runner.getTotalEventsForAccount("acct-1"));

// Demonstrate pagination for all devices
System.out.println("First list -- acct-1, all devices");
List<Event> events = runner.getEventsBefore("acct-1", null, 50);
displayEvents(events);

events = runner.getEventsBefore("acct-1", getLastElement(events).getId(), 50);
System.out.println("\nSecond page:");
displayEvents(events);

// Demonstrate device-specific filtering
System.out.println("First list -- acct-1, devices 1, 2, 3");
int pageSize = 25;
events = runner.getEventsBefore("acct-1", null, pageSize, 
    "device-acct-1-1", "device-acct-1-2", "device-acct-1-3");
displayEvents(events);

        
int pageCounter = 1;
String eventIdAtTopOfPage = null;
while (events.size() == pageSize) {
    System.out.printf("Page %,d%n", ++pageCounter);
    eventIdAtTopOfPage = getLastElement(events).getId();
    events = runner.getEventsBefore("acct-1", eventIdAtTopOfPage, pageSize, 
        "device-acct-1-1", "device-acct-1-2", "device-acct-1-3");
    displayEvents(events);
}
```

This will display results of these queries being run (output truncated for brevity):
```
First list -- acct-1, all devices
 1: 1753709610770000543236963 - Mon Jul 28 20:33:30 ICT 2025 - device-acct-1-8
 2: 1753709477547001097674095 - Mon Jul 28 20:31:17 ICT 2025 - device-acct-1-18
 3: 1753709431477000325483405 - Mon Jul 28 20:30:31 ICT 2025 - device-acct-1-12
 4: 1753709423512000056973694 - Mon Jul 28 20:30:23 ICT 2025 - device-acct-1-12
 ...
47: 1753704124061001859963613 - Mon Jul 28 19:02:04 ICT 2025 - device-acct-1-15
48: 1753703944362001061345165 - Mon Jul 28 18:59:04 ICT 2025 - device-acct-1-7
49: 1753703586659001292373458 - Mon Jul 28 18:53:06 ICT 2025 - device-acct-1-9
50: 1753703530831001037349693 - Mon Jul 28 18:52:10 ICT 2025 - device-acct-1-6

Second page:
 1: 1753703530489001347487479 - Mon Jul 28 18:52:10 ICT 2025 - device-acct-1-15
 2: 1753703359447001045860422 - Mon Jul 28 18:49:19 ICT 2025 - device-acct-1-7
 3: 1753703085268001474394633 - Mon Jul 28 18:44:45 ICT 2025 - device-acct-1-16
 4: 1753702983883000368486293 - Mon Jul 28 18:43:03 ICT 2025 - device-acct-1-10
...
47: 1753696865387001557211843 - Mon Jul 28 17:01:05 ICT 2025 - device-acct-1-16
48: 1753696603672001516332585 - Mon Jul 28 16:56:43 ICT 2025 - device-acct-1-16
49: 1753696384609000158564931 - Mon Jul 28 16:53:04 ICT 2025 - device-acct-1-2
50: 1753696326608000172377453 - Mon Jul 28 16:52:06 ICT 2025 - device-acct-1-7
First list -- acct-1, devices 1, 2, 3
 1: 1753708851517001570696842 - Mon Jul 28 20:20:51 ICT 2025 - device-acct-1-2
 2: 1753708101629000912649231 - Mon Jul 28 20:08:21 ICT 2025 - device-acct-1-2
 3: 1753707736896001274820979 - Mon Jul 28 20:02:16 ICT 2025 - device-acct-1-2
 4: 1753707592444000271009837 - Mon Jul 28 19:59:52 ICT 2025 - device-acct-1-3
 5: 1753707420570001794577281 - Mon Jul 28 19:57:00 ICT 2025 - device-acct-1-2
 6: 1753707326969001095668299 - Mon Jul 28 19:55:26 ICT 2025 - device-acct-1-2
 7: 1753706463323000729361632 - Mon Jul 28 19:41:03 ICT 2025 - device-acct-1-1
 8: 1753705933238001970192973 - Mon Jul 28 19:32:13 ICT 2025 - device-acct-1-1
 9: 1753705147423000009548683 - Mon Jul 28 19:19:07 ICT 2025 - device-acct-1-1
10: 1753705099692001842210622 - Mon Jul 28 19:18:19 ICT 2025 - device-acct-1-1
11: 1753705010320000320198031 - Mon Jul 28 19:16:50 ICT 2025 - device-acct-1-1
12: 1753702361999000821727046 - Mon Jul 28 18:32:41 ICT 2025 - device-acct-1-3
13: 1753702121880000211394871 - Mon Jul 28 18:28:41 ICT 2025 - device-acct-1-1
14: 1753701189711001985475285 - Mon Jul 28 18:13:09 ICT 2025 - device-acct-1-2
15: 1753700321908001638470555 - Mon Jul 28 17:58:41 ICT 2025 - device-acct-1-1
16: 1753700059119001880049919 - Mon Jul 28 17:54:19 ICT 2025 - device-acct-1-2
17: 1753699667723001634335104 - Mon Jul 28 17:47:47 ICT 2025 - device-acct-1-3
18: 1753698971482000557077224 - Mon Jul 28 17:36:11 ICT 2025 - device-acct-1-2
19: 1753698935761000624693084 - Mon Jul 28 17:35:35 ICT 2025 - device-acct-1-3
20: 1753698763879001823299628 - Mon Jul 28 17:32:43 ICT 2025 - device-acct-1-2
21: 1753698710987001038202906 - Mon Jul 28 17:31:50 ICT 2025 - device-acct-1-3
22: 1753698691186000262667576 - Mon Jul 28 17:31:31 ICT 2025 - device-acct-1-2
23: 1753698676997002082806501 - Mon Jul 28 17:31:16 ICT 2025 - device-acct-1-3
24: 1753698111104001792971475 - Mon Jul 28 17:21:51 ICT 2025 - device-acct-1-2
25: 1753698052033000247711795 - Mon Jul 28 17:20:52 ICT 2025 - device-acct-1-3
Page 2
 1: 1753697821061001634190700 - Mon Jul 28 17:17:01 ICT 2025 - device-acct-1-3
 2: 1753697686875001563223717 - Mon Jul 28 17:14:46 ICT 2025 - device-acct-1-1
 3: 1753696384609000158564931 - Mon Jul 28 16:53:04 ICT 2025 - device-acct-1-2
...
24: 1753686551684000132591776 - Mon Jul 28 14:09:11 ICT 2025 - device-acct-1-1
25: 1753686482931000491501142 - Mon Jul 28 14:08:02 ICT 2025 - device-acct-1-3
Page 3
 1: 1753685879651001689827916 - Mon Jul 28 13:57:59 ICT 2025 - device-acct-1-2
 2: 1753685226319001417236890 - Mon Jul 28 13:47:06 ICT 2025 - device-acct-1-3
...
24: 1753667069455001145633402 - Mon Jul 28 08:44:29 ICT 2025 - device-acct-1-3
25: 1753666681195001230861218 - Mon Jul 28 08:38:01 ICT 2025 - device-acct-1-2
Page 4
 1: 1753666472950001033738823 - Mon Jul 28 08:34:32 ICT 2025 - device-acct-1-3
 2: 1753666135807001568506528 - Mon Jul 28 08:28:55 ICT 2025 - device-acct-1-3
 ...
```